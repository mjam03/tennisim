from typing import Tuple

from tennisim.game import prob_game
from tennisim.set import prob_set
from tennisim.tiebreak import prob_tiebreak
from tennisim.utils import comb


def prob_match_outcome(
    p_set: float, st_a: int, st_b: int, sets: int = 3
) -> Tuple[float, dict]:
    """Computes probability of player 'a' winning the match given an initial
    scoreline of (sta_, st_b) and returns a tuple of this prob along with the
    individual scorelines that make this up e.g. if (0,0) and 0.5 would be:
    {0.5, {(2,0): 0.5, (2,1): 0.25})

    Args:
        p_set (float): probability that 'a' wins a given set
        st_a (int): sets already won by 'a'
        st_b (int): sets already won by 'b'
        sets (int, optional): how many sets match is 'best of'. Defaults to 3.

    Returns:
        Tuple[float, dict]: prob that 'a' wins match and dict of:
        {score_line: probab}
    """

    # solve corners first - you win by winning best of sets
    win_m = sets // 2 + 1
    if st_a == win_m:
        return 1.00, {}
    elif st_b == win_m:
        return 0.00, {}

    poss_set_scores = [(win_m, x) for x in range(st_b, win_m)]
    need_set_scores = [(x - st_a, y - st_b) for x, y in poss_set_scores]

    match_outcomes = {}
    for ps, ns in zip(poss_set_scores, need_set_scores):
        # subtract 1 as has to win final set
        s_needed = ns[0] - 1
        sets_played = sum(ns) - 1
        prob_s = (
            p_set
            * comb(sets_played, s_needed)
            * p_set ** s_needed
            * (1 - p_set) ** (sets_played - s_needed)
        )
        match_outcomes[ps] = prob_s

    return sum(match_outcomes.values()), match_outcomes


def prob_match(
    p_a: float,
    p_b: float,
    st_a: int = 0,
    st_b: int = 0,
    g_a: int = 0,
    g_b: int = 0,
    pt_a: int = 0,
    pt_b: int = 0,
    sets: int = 3,
) -> float:
    """Given a state of a tennis match in sets, games and points; returns the
    probability that the player will win the match.

    Args:
        p_a (float): prob that player 'a' wins a point on their serve
        p_b (float): prob that player 'b' wins a point on their serve
        st_a (int, optional): sets already won by 'a'. Defaults to 0.
        st_b (int, optional): sets already won by 'b'. Defaults to 0.
        g_a (int, optional): games in curr set won by 'a'. Defaults to 0.
        g_b (int, optional): games in curr set won by 'b'. Defaults to 0.
        pt_a (int, optional): points in curr game won by 'a'. Defaults to 0.
        pt_b (int, optional): points in curr game won by 'b'. Defaults to 0.
        sets (int, optional): how many sets match is 'best of'. Defaults to 3.

    Returns:
        float: probability that player 'a' wins the match
    """

    # check corners first
    win_m = sets // 2 + 1
    if st_a == win_m:
        return 1.00
    elif st_b == win_m:
        return 0.00

    p_set = prob_set(p_a, p_b, 0, 0)
    # check if we haven't started yet
    if pt_a == 0 and pt_b == 0:
        if g_a == 0 and g_b == 0:
            if st_a == 0 and st_b == 0:
                return prob_match_outcome(p_set, 0, 0)[0]
            else:
                # we have sets played but no games yet
                p_this_set = p_set
        else:
            # we have played games in this set
            # let's compute prob of winning set
            p_this_set = prob_set(p_a, p_b, g_a, g_b)
    elif g_a == 6 and g_b == 6:
        # then we're in tiebreak
        # so prob of winning set different
        p_this_set = prob_tiebreak(p_a, p_b, pt_a, pt_b)[0]
    else:
        # we have played points in this game
        # we can compute prob of winning set
        # by adding prob we win set if we win this game
        # with prob we win this set if we lose this game
        p_this_game = prob_game(p_a, pt_a, pt_b)
        # we want prob we win the set here if we win the game
        # but if we serve this game then they serve the next
        # so we need to view it from ther perspective
        p_this_set_if_w = p_this_game * (1 - prob_set(p_b, p_a, g_b, g_a + 1))
        p_this_set_if_l = (1 - p_this_game) * (
            1 - prob_set(p_b, p_a, g_b + 1, g_a)
        )
        p_this_set = p_this_set_if_w + p_this_set_if_l

    # so now we have the probability of winning the set we are in
    # prob we win match is prob we win if we win this set
    # plus prob we win if we lose this set

    p_match_w_set = (
        p_this_set * prob_match_outcome(p_set, st_a + 1, st_b, sets=sets)[0]
    )
    p_match_l_set = (1 - p_this_set) * prob_match_outcome(
        p_set, st_a, st_b + 1, sets=sets
    )[0]
    p_match = p_match_w_set + p_match_l_set
    return p_match


def reformat_match(match_data: list, p_a: float, p_b: float) -> list:
    """Reformats data generated by match simulation for ease of analysis

    Args:
        match_data (list): output of match simulation function sim_match
        p_a (float): prob that player 'a' wins a given point on serve
        p_b (float): prob that player 'b' wins a given point on serve

    Returns:
        list: list of points in chronological order of the sim'ed tennis match
    """

    points = []
    game_count = 0
    point_count = 0
    set_prog = match_data[1]
    game_progs = match_data[2]
    point_progs = match_data[3]

    for i, set_score in enumerate(set_prog):
        if i == 0:
            # then we haven't played a set yet
            # so set score is 0,0
            st_a = 0
            st_b = 0
        else:
            # grab previous set score
            st_a = set_prog[i - 1][0]
            st_b = set_prog[i - 1][1]

        # grab the games in the set
        games = game_progs[i]
        # for each game in that set
        for j, g in enumerate(games):
            if j == 0:
                # then we haven't played any games yet
                g_a = 0
                g_b = 0
            else:
                g_a = games[j - 1][0]
                g_b = games[j - 1][1]

            # now grab the point score in the game
            pts = point_progs[i][j]
            pts = [(0, 0)] + pts[:-1]
            for k, p in enumerate(pts):
                if k == 0:
                    # we haven't played any points yet
                    pt_a = 0
                    pt_b = 0
                else:
                    # if we have an even game count
                    # then 'a' is serving so keep as is
                    if game_count % 2 == 0:
                        pt_a = p[0]
                        pt_b = p[1]
                    else:
                        # else reverse them
                        pt_a = p[1]
                        pt_b = p[0]

                # now compute win probab for player 'a'
                # first check special situation of being in tiebreak
                if g_a == 6 and g_b == 6:
                    # then in tiebreak
                    if game_count % 2 == 0:
                        # then 'a' should serve first point of tiebreak
                        # e.g. if we've played 1,2 points in tb then 'b' serve
                        if (pt_a + pt_b) % 4 == 1 or (pt_a + pt_b) % 4 == 1:
                            p = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a
                            )
                            p_w = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a + 1
                            )
                            p_l = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b + 1, pt_a
                            )
                        else:
                            # then 'a' is serving
                            p = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b
                            )
                            p_w = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a + 1, pt_b
                            )
                            p_l = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b + 1
                            )
                    else:
                        # we have the reverse where b serves first point of tb
                        if (pt_a + pt_b) % 4 == 1 or (pt_a + pt_b) % 4 == 1:
                            # then 'a' is serving
                            p = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b
                            )
                            p_w = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a + 1, pt_b
                            )
                            p_l = prob_match(
                                p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b + 1
                            )
                        else:
                            p = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a
                            )
                            p_w = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a + 1
                            )
                            p_l = 1 - prob_match(
                                p_b, p_a, st_b, st_a, g_b, g_a, pt_b + 1, pt_a
                            )
                else:
                    # we're not in the tiebreak so much easier
                    if game_count % 2 == 0:
                        # then 'a' serving
                        p = prob_match(
                            p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b
                        )
                        p_w = prob_match(
                            p_a, p_b, st_a, st_b, g_a, g_b, pt_a + 1, pt_b
                        )
                        p_l = prob_match(
                            p_a, p_b, st_a, st_b, g_a, g_b, pt_a, pt_b + 1
                        )
                    else:
                        p = 1 - prob_match(
                            p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a
                        )
                        p_w = 1 - prob_match(
                            p_b, p_a, st_b, st_a, g_b, g_a, pt_b, pt_a + 1
                        )
                        p_l = 1 - prob_match(
                            p_b, p_a, st_b, st_a, g_b, g_a, pt_b + 1, pt_a
                        )

                # now add this data to a map
                p_map = {
                    "st_a": st_a,
                    "st_b": st_b,
                    "g_a": g_a,
                    "g_b": g_b,
                    "pt_a": pt_a,
                    "pt_b": pt_b,
                    "p_a": p_a,
                    "p_b": p_b,
                    "pc": point_count,
                    "gc": game_count,
                    "sc": st_a + st_b,
                    "prob": p,
                    "prob_w": p_w,
                    "prob_l": p_l,
                }

                point_count += 1
                points.append(p_map)

            # bump game count up
            game_count += 1

    # add on final score
    st_a = set_prog[-1][0]
    st_b = set_prog[-1][1]
    p = prob_match(p_a, p_b, st_a, st_b)
    p_map = {
        "st_a": set_prog[-1][0],
        "st_b": set_prog[-1][1],
        "g_a": 0,
        "g_b": 0,
        "pt_a": 0,
        "pt_b": 0,
        "p_a": p_a,
        "p_b": p_b,
        "pc": point_count,
        "gc": game_count,
        "sc": st_a + st_b,
        "prob": p,
        "prob_w": p,
        "prob_l": p,
    }
    points.append(p_map)

    return points
